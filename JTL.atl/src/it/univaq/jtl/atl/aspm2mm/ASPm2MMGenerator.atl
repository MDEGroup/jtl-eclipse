-- @atlcompiler atl2006

-- @name		ASPm2MMGenerator
-- @version		1.0
-- @authors		Ivano Malavolta
-- @date		2009/09/21
-- @description	${description}

-- This is the higher-order transformation that takes as input an Ecore metamodel MMx and produces
-- a model transformation producing a model conforming to MMx from its corresponding ASPm version.

query ASPm2MMGenerator = (ECORE!EClass.allInstancesFrom('IN')->iterate(e; acc : String = 
	'-- @atlcompiler atl2006\n' +
	'-- Generated by: ASPm2MMGenerator\n' +
	'module ASPm2' + thisModule.getRoot().name.toKString() + ';\n\n' +
	'create OUT : ' + thisModule.getRoot().name.toKString() + ' from IN : ASPm; \n\n' +
	'helper context String def : denormalize() : String = self.replaceAll(\'"\', \' \').trim().substring(3, self.size()).processList();\n' +
	'helper context String def : processList() : String = self.regexReplaceAll(\'\\\\w+\\\\(\\\\[([^\\\\]]+)\\\\]\\\\)\', \'$1\').regexReplaceAll(\' x_([^ ]+) \',\'$1\');\n\n' +
	'helper context ASPm!Node def: getProps(name:String) : Sequence(ASPm!Prop) = ASPm!Prop.allInstancesFrom(\'IN\')->select(e | e.name.denormalize() = name and e.owner = self);\n' +
	'helper context ASPm!Node def: getEdges(name:String) : Sequence(ASPm!Edge) = ASPm!Edge.allInstancesFrom(\'IN\')->select(e | e.name.denormalize() = name and e.source = self);\n' +
	'helper context ASPm!Node def: serializeNodeID() : String =	\'ASPid_\' + self.ID + \'_\' + self.IDtrace.denormalize();\n' +
	'helper context ASPm!Node def: serializePropIDs(name:String) : String =	if (self.getProps(name).isEmpty()) then \'\'\n' +
	'  else self.getProps(name)->collect(s | \'-\' + name + \'_\' + s.ID + \'_\' + s.IDtrace.denormalize()).sum() endif;\n' +
	'helper context ASPm!Node def: serializeEdgeIDs(name:String) : String =	if (self.getEdges(name).isEmpty()) then \'\'\n' +
	'  else self.getEdges(name)->collect(s | \'-\' + name + \'t\' + s.target.ID + \'_\' + s.ID + \'_\' + s.IDtrace.denormalize()).sum()	endif;\n\n'
	| acc + e.classToRuleString()) +
	ECORE!EEnum.allInstancesFrom('IN')->iterate(e; acc : String = ''
	| acc + e.enumerationToRuleString()))
	.println();
--	.writeTo(('ASPm2' + thisModule.getRoot().name + '.atl').path);

-- adapt the following helper to reflect your file path
helper context String def : path : String =
	 '/TEST.generated.ASPm2MM/transformation/' + self;

helper context ECORE!EEnum def : enumerationToRuleString() : String =
			'helper def : get' + self.name.firstToUpper() + 'Value(literal : String) : ' + thisModule.getRoot().name.toKString() + '!' + self.rulename + ' =\n' +
			'\t' + thisModule.getRoot().name.toKString() + '!' + self.rulename + '.getEEnumLiteral(literal.replaceAll(\'#\', \' \').trim());\n\n';	

helper context ECORE!EClass def : classToRuleString() : String =
			'rule ' + self.rulename + ' {\n' +
			'\tfrom s : ASPm!Node(s.name.denormalize() = \'' + self.cname + '\')\n' +	
			'\tto  t : ' + thisModule.getRoot().name.toKString() + '!' + self.cname + ' (\n' + 
			self.eAllStructuralFeatures->iterate(e; acc : String = '' | acc + e.featureToBindingString() + if(e.isLast(self.eAllStructuralFeatures)) then '' else ',' endif + '\n') +
			'\t)\n' +
			'\tdo {\n'+
			'\t\tt.__xmiID__ <- s.serializeNodeID()' +
			self.eAllStructuralFeatures
			  ->collect(f | '\n\t\t+ s.serialize' + 
			      if(f.oclIsTypeOf(ECORE!EReference)) then 'Edge' else 'Prop' endif +
			      'IDs(\'' + f.name.toKString() + '\')').sum() +
			';\n\t}\n'+
			'}\n\n';
			
helper context ECORE!EStructuralFeature def : featureToBindingStringID() : String =
	if(self.oclIsTypeOf(ECORE!EReference)) then
		self.referenceToBindingStringID()
	else
		self.attributeToBindingStringID()
	endif;				
helper context ECORE!EReference def : referenceToBindingStringID() : String =
		'\t\t\'_' + self.name.toKString() + '_\' + ' + 'ASPm!Edge.allInstancesFrom(\'IN\')->select(e | e.name.denormalize() = \'' + self.name + '\' and e.source = s)'
		+ if(self.upperBound <> 1) then '' else '.first()' endif + '.ID';
helper context ECORE!EAttribute def : attributeToBindingStringID() : String =
		'\t\t\'_' + self.name.toKString() + '_\' + ' + 'ASPm!Prop.allInstancesFrom(\'IN\')->select(e | e.name.denormalize() = \'' + self.name + '\' and e.owner = s)'
		+ if(self.upperBound <> 1) then '' else '.first()' endif + '.ID';
			
			
			
helper context ECORE!EStructuralFeature def : featureToBindingString() : String =
	if(self.oclIsTypeOf(ECORE!EReference)) then
		self.referenceToBindingString()
	else
		self.attributeToBindingString()
	endif;
				
helper context ECORE!EReference def : referenceToBindingString() : String =
		'\t\t' + self.name.toKString() + ' <- ASPm!Edge.allInstancesFrom(\'IN\')->select(e | e.name.denormalize() = \'' + self.name + '\' and e.source = s)->collect(e | e.target)'
		+ if(self.upperBound <> 1) then '' else '.first()' endif;

helper context ECORE!EAttribute def : attributeToBindingString() : String =
		'\t\t' + self.name.toKString() + ' <- ASPm!Prop.allInstancesFrom(\'IN\')->select(e | e.name.denormalize() = \'' + self.name + '\' and e.owner = s)->collect(e | ' + self.getToTypeCallExp('e') + ')'
		+ if(self.upperBound <> 1) then '' else '.first()' endif;


-- this helper manages only the primitive types that ATL can handle
helper context ECORE!EAttribute def : getToTypeCallExp(varName : String) : String =
	if(self.eAttributeType = ECORE!EString)
		then varName + '.value.denormalize()'
		else 
			if(self.eAttributeType = ECORE!EBoolean)
			then varName + '.value.denormalize().toBoolean()'
			else
				if(self.eAttributeType = ECORE!EInt)
				then varName + '.value.denormalize().toInteger()'
				else
					if(self.eAttributeType = ECORE!EDouble)
					then varName + '.value.denormalize().toReal()'
					else
						if(self.eAttributeType.oclIsTypeOf(ECORE!EEnum))
						then 'thisModule.get' + self.eType.name.firstToUpper() + 'Value(' + varName + '.value.denormalize())'
						else varName + '.value'
					endif
				endif
			endif
		endif 
	endif;

helper context String def: firstToUpper() : String =
	self->substring(1, 1)->toUpper() + self->substring(2, self->size());

helper context OclAny def : isLast(list : Sequence(OclAny)) : Boolean =
	list.last() = self;
			
helper context OclAny def: isRoot() : Boolean = self.refImmediateComposite().oclIsUndefined();

helper def: getRoot() : ECORE!EPackage = ECORE!EPackage.allInstancesFrom('IN')->any(e | e.isRoot());
			
helper context ECORE!ENamedElement def : qName : String =
	self.name;

helper context ECORE!EClassifier def : qName : String =
	if self.ePackage.oclIsUndefined() then
		self.name
	else
		self.ePackage.qName + '::' + self.name
	endif;

helper context ECORE!EPackage def : qName : String =
	if self.eSuperPackage.oclIsUndefined() then
		self.name
	else
		self.eSuperPackage.qName + '::' + self.name
	endif;

helper context ECORE!ENamedElement def : cname : String =
	if self.useQualifiedName then
		'"' + self.qName + '"'
	else
		if self.name.isKeyword then
			'"' + self.name + '"'
		else
			self.name
		endif
	endif;

helper context ECORE!ENamedElement def : rulename : String =
	if self.useQualifiedRuleName then
		'"' + self.qName + '"'
	else
		if self.name.isKeyword then
			'"' + self.name + '"'
		else
			self.name
		endif 
	endif;

helper context String def : toKString() : String =
	if self.isKeyword then
		'"' + self + '"'
	else
		self
	endif;

-- adapt the following inclusion condition for your specific model
helper context ECORE!"ecore::EClass" def : inclusionCondition : Boolean =
	not (
    	-- self.name = 'EAttribute' or
	    -- self.name = 'EClass' or
		-- self.name = 'EDataType' or
		-- self.name = 'EEnum' or
		-- self.name = 'EEnumLiteral' or
		self.name = 'EFactory' or
		self.name = 'EObject' or
		self.name = 'EOperation' or
		-- self.name = 'EPackage' or
		self.name = 'EParameter' or
		-- self.name = 'EReference' or
		self.name = 'Profile' or
		self.name = 'Stereotype'
	);

-- select whether or not to use fully qualified meta-class names (<package>::<class>)
helper context ECORE!"ecore::ENamedElement" def : useQualifiedName : Boolean =
	false; 

-- select whether or not to use fully qualified rule names (<package>::<class>)
helper context ECORE!"ecore::ENamedElement" def : useQualifiedRuleName : Boolean =
	false;

-- select whether or not to copy the __xmiid__ attribute
helper context ECORE!"ecore::EClass" def : copyXmiID : Boolean =
	false;

helper context String def : isKeyword : Boolean =
	Set{'module', 'create', 'from', 'rule', 'to', 'using', 'helper', 'context',
		'def', 'and', 'or', 'not', 'if', 'then', 'else', 'endif', 'query',
		'library', 'mapsTo', 'String', 'Boolean', 'Integer', 'Real', 'Bag',
		'Set', 'OrderedSet', 'Sequence', 'abstract', 'derived', 'refining',
		'foreach', 'distinct', 'in', 'do', 'uses', 'let', 'TupleType'}->includes(self);

