---------------------------------------------------------------------------------------------------
-- Create an ASP model from a JTL model
---------------------------------------------------------------------------------------------------
module JTLtoASP; 
create OUT: ASP from IN: JTL;

---------------------------------------------------------------------------------------------------
--                                            HELPERS
---------------------------------------------------------------------------------------------------

-- IDs counters
helper def: nodeId: Integer = 0; 		---This variable is a counter for the creation of node ids
helper def: propId: Integer = 0; 		---This helper is a counter for the creation of prop ids
helper def: edgeId: Integer = 0; 		---This helper is a counter for the creation of edge ids
helper def: ruleId: Integer = 0; 		---This helper is a counter for the creation of rules ids
helper def: constraintId: Integer = 0; 	---This helper is a counter for the creation of contraints ids

-- ASP model root element
helper def: transformation: ASP!Transformation = ASP!Transformation;

-- Maps of generated elements for reuse
helper def: literals: Map (String, ASP!Literal) = Map {};
helper def: nodes: Map (String, ASP!Node) = Map {};
helper def: nodexs: Map (String, ASP!Node) = Map {};
helper def: props: Map (String, ASP!Prop) = Map {};
helper def: propxs: Map (String, ASP!Prop) = Map {};
helper def: edges: Map (String, ASP!Edge) = Map {};
helper def: edgexs: Map (String, ASP!Edgex) = Map {};
helper def: metanodes: Map (String, ASP!Node) = Map {};
helper def: metaprops: Map (String, ASP!Prop) = Map {};
helper def: metaedges: Map (String, ASP!Edge) = Map {};
helper def: namedfunctions: Map (String, ASP!NamedFunction) = Map {};

--- Generate an element identifier string used to store the element in a map
helper def: toKey(s : Sequence(String)) : String = s->collect(e|e+'_').sum().regexReplaceAll('_$','');

--- Generate a key from an Element
helper context ASP!Element def: getKey() : String = thisModule.toKey(self.literals->collect(l|l.name));

--- Add the suffix 'x_'
helper context String def: normalize() : String = if (self.startsWith('x_')) then self else 'x_' + self endif;

--- Return a Literal by this name
helper def: getLiteral(name : String) : ASP!Literal =
    if (thisModule.literals->get(name).oclIsUndefined())
        then thisModule.newLiteral(name)
        else thisModule.literals->get(name)
    endif;

--- Return a Node with this literals
helper def: getNode(mm : String, id : String, idx : String, mc : String) : ASP!Node =
    if (thisModule.nodes->get(thisModule.toKey(Sequence{mm, id, idx, mc})).oclIsUndefined())
        then thisModule.newNode(mm, id, idx, mc)
        else thisModule.nodes->get(thisModule.toKey(Sequence{mm, id, idx, mc}))
    endif;

--- Return a Nodex with this literals
helper def: getNodex(mm : String, id : String, idx : String, mc : String) : ASP!Node =
    if (thisModule.nodexs->get(thisModule.toKey(Sequence{mm, id, idx, mc})).oclIsUndefined())
        then thisModule.newNodex(mm, id, idx, mc)
        else thisModule.nodexs->get(thisModule.toKey(Sequence{mm, id, idx, mc}))
    endif;

--- Return a Prop with this literals
helper def: getProp(mm : String, idp : String, idpx : String, id : String,
             		idx : String, name : String, value : String) : ASP!Prop =
    if (thisModule.props->get(
        	thisModule.toKey(Sequence{mm, idp, idpx, id, idx, name, value})).oclIsUndefined())
        then thisModule.newProp(mm, idp, idpx, id, idx, name, value)
        else thisModule.props->get(thisModule.toKey(Sequence{mm, idp, idpx, id, idx, name, value}))
    endif;

--- Return a Propx with this literals
helper def: getPropx(mm : String, idp : String, idpx : String, id : String,
             		 idx : String, name : String, value : String) : ASP!Prop =
    if (thisModule.propxs->get(
        	thisModule.toKey(Sequence{mm, idp, idpx, id, idx, name, value})).oclIsUndefined())
        then thisModule.newPropx(mm, idp, idpx, id, idx, name, value)
        else thisModule.propxs->get(thisModule.toKey(Sequence{mm, idp, idpx, id, idx, name, value}))
    endif;

--- Return an Edge with this literals
helper def: getEdge(mm : String, ide : String, idex : String, name : String,
             		ids : String, idsx : String, idt : String, idtx : String) : ASP!Edge =
    if (thisModule.edges->get(
        	thisModule.toKey(Sequence{mm, ide, idex, name, ids, idsx, idt, idtx})).oclIsUndefined())
        then thisModule.newEdge(mm, ide, idex, name, ids, idsx, idt, idtx)
        else thisModule.edges->get(thisModule.toKey(Sequence{mm, ide, idex, name, ids, idsx, idt, idtx}))
    endif;

--- Return an Edgex with this literals
helper def: getEdgex(mm : String, ide : String, idex : String, name : String,
             		 ids : String, idsx : String, idt : String, idtx : String) : ASP!Edge =
    if (thisModule.edgexs->get(
        	thisModule.toKey(Sequence{mm, ide, idex, name, ids, idsx, idt, idtx})).oclIsUndefined())
        then thisModule.newEdgex(mm, ide, idex, name, ids, idsx, idt, idtx)
        else thisModule.edgexs->get(thisModule.toKey(Sequence{mm, ide, idex, name, ids, idsx, idt, idtx}))
    endif;

--- Return a Metanode with this literals
helper def: getMetanode(mm : String, mc : String) : ASP!Metanode =
    if (thisModule.metanodes->get(thisModule.toKey(Sequence{mm, mc})).oclIsUndefined())
        then thisModule.newMetanode(mm, mc)
        else thisModule.metanodes->get(thisModule.toKey(Sequence{mm, mc}))
    endif;

--- Return a Metanode from a Pattern
helper context JTL!Pattern def: getMetanode() : ASP!Metanode =
	thisModule.getMetanode(self.getMetamodel(), self.getMetaclass());

--- Return a Metaprop with this literals
helper def: getMetaprop(mm : String, name : String, mc : String) : ASP!Metaprop =
    if (thisModule.metaprops->get(thisModule.toKey(Sequence{mm, name, mc})).oclIsUndefined())
        then thisModule.newMetaprop(mm, name, mc)
        else thisModule.metaprops->get(thisModule.toKey(Sequence{mm, name, mc}))
    endif;

--- Return a Metaedge with this literals
helper def: getMetaedge(mm : String, name : String, mcs : String, mct : String) : ASP!Metaedge =
    if (thisModule.metaedges->get(thisModule.toKey(Sequence{mm, name, mcs, mct})).oclIsUndefined())
        then thisModule.newMetaedge(mm, name, mcs, mct)
        else thisModule.metaedges->get(thisModule.toKey(Sequence{mm, name, mcs, mct}))
    endif;

--- Return a Metaedge from an AssignExp
helper context JTL!AssignExp def: getMetaedge() : ASP!Metaedge =
    thisModule.getMetaedge(self.getMetamodel(), self.left.name, self.getSourceMetaclass(), self.getTargetMetaclass());

--- Return a NamedFunction with this literals
helper def: getNamedFunction(name : String, literals : Sequence(String)) : ASP!NamedFunction =
    if (thisModule.namedfunctions->get(thisModule.toKey(literals->prepend(name))).oclIsUndefined())
    	then thisModule.newNamedFunction(name, literals)
    	else thisModule.namedfunctions->get(thisModule.toKey(literals->prepend(name)))
    endif;

--- Get metamodel from Domain
helper context JTL!Domain def: getMetamodel() : String = self.model.usedPackage;

--- Get metamodel from Pattern
helper context JTL!Pattern def: getMetamodel() : String = self.domain.getMetamodel();

--- Get metamodel from AssignExp
helper context JTL!AssignExp def: getMetamodel() : String = self.value.first().type;

--- Get metaclass from Pattern
helper context JTL!Pattern def: getMetaclass() : String = self.templateExpression.referredClass;

--- Get source metaclass from AssignExp
helper context JTL!AssignExp def: getSourceMetaclass() : String =
    if self->refImmediateComposite()->oclIsTypeOf(JTL!Predicate)
    	then self->refImmediateComposite().pattern.getMetaclass()
    	else self->refImmediateComposite().referredClass
    endif;

--- Get target metaclass from AssignExp
helper context JTL!AssignExp def: getTargetMetaclass() : String = self.value.first().referredClass;

--- Get metaedge name from ObjectTemplateExp
helper context JTL!ObjectTemplateExp def: getMetaedgeName() : String = self->refImmediateComposite().left.name;

--- Check if a Predicate is the assignment of a variable
helper context JTL!Predicate def: isVarExp() : Boolean =
    self.conditionExpression.oclIsTypeOf(JTL!AssignExp) and
    self.conditionExpression.value.first().oclIsTypeOf(JTL!VariableExp);

--- Check if an AssignExp contains an ObjectTemplateExp
helper context JTL!AssignExp def: isObjTplExp() : Boolean =
    self.value.first().oclIsTypeOf(JTL!ObjectTemplateExp);

--- Check if a ASP!Relation between given Metanodes already exists
helper def: relationNodeExists(m1 : ASP!Metanode, m2 : ASP!Metanode) : Boolean =
    thisModule.transformation.relations
    	->select(r|r.patterns->at(1).element = m1 and r.patterns->at(2).element = m2)
    	.notEmpty();

--- Check if a ASP!Relation between given Metaedges already exists
helper def: relationEdgeExists(m1 : ASP!Metaedge, m2 : ASP!Metaedge) : Boolean =
    thisModule.transformation.relations
    	->select(r|r.patterns->at(1).element = m1 and r.patterns->at(2).element = m2)
    	.notEmpty();

--- Check if the OperationCallExp of the Predicate matches a JTL!Relation and its arguments types
helper context JTL!Predicate def: OpCallExpMatchesRelation(r : JTL!Relation) : Boolean =
	not self.conditionExpression.oclIsUndefined() and				-- not undefined
	self.conditionExpression.oclIsTypeOf(JTL!OperationCallExp) and	-- and of type OperationCallExp
	self.conditionExpression.referredOperation = r and				-- matching Relation
	(self.conditionExpression.argument->at(1).referredClass = r.domain->at(1).pattern.templateExpression.referredClass and
	 self.conditionExpression.argument->at(2).referredClass = r.domain->at(2).pattern.templateExpression.referredClass);

--- Check if a Predicate matches one of the parameters (metaclasses) of an OperationCallExp
helper context JTL!Predicate def: predMatchesOpCallParams(p : JTL!Predicate) : Boolean =
	not p.conditionExpression.oclIsUndefined() and									-- OperationCallExp not undefined
	not p.conditionExpression.argument.oclIsUndefined() and							-- arguments not undefined
	not p.conditionExpression.argument->at(1).oclIsUndefined() and					-- first argument not undefined
	not p.conditionExpression.argument->at(2).oclIsUndefined() and					-- second argument not undefined
	p.conditionExpression.argument->at(1).oclIsTypeOf(JTL!ObjectTemplateExp) and	-- first argument is ObjectTemplateExp
	p.conditionExpression.argument->at(2).oclIsTypeOf(JTL!ObjectTemplateExp) and	-- second argument is ObjectTemplateExp
	self.conditionExpression.isObjTplExp() and								-- not undefined and of type OperationCallExp
	-- match one of the two parameters metaclasses
	(self.conditionExpression.value.first().name = p.conditionExpression.argument->at(1).name or
	 self.conditionExpression.value.first().name = p.conditionExpression.argument->at(2).name);

--- Check if a relation is activated by a where clause
helper context JTL!Relation def: isTriggeredByWhere() : Boolean =
    self.isTopLevel=false and                                    -- the Relation is not 'top'
    self.transformation.relation                                 -- and in any other relation
      ->select(r|not r.where.oclIsUndefined())                   -- having a defined where clause
      ->collect(r|r.where.predicate)->flatten()                  -- there exists a predicate referring to this relation
      ->exists(p|p.OpCallExpMatchesRelation(self));              -- and matching name and parameters types

--- Get the relation triggering this one
helper context JTL!Relation def: getTriggeringRelation(): JTL!Relation =
    if self.isTopLevel=true then self else
      self.transformation.relation
        ->select(r|not r.where.oclIsUndefined())
        ->collect(r|r.where.predicate)->flatten()
        ->select(p|p.OpCallExpMatchesRelation(self))
        ->at(1).refImmediateComposite().refImmediateComposite()
    endif;

--- Get the relation triggering this one
helper context JTL!Relation def: getTriggeringRelations(): Sequence(JTL!Relation) =
    if self.isTopLevel=true then Sequence{} else
      self.transformation.relation
        ->select(r|not r.where.oclIsUndefined())
        ->collect(r|r.where.predicate)->flatten()
        ->select(p|p.OpCallExpMatchesRelation(self))
        ->collect(p|p.refImmediateComposite().refImmediateComposite())
    endif;

--- Return the Predicate containing this AssignExp
helper context JTL!AssignExp def: getPredicateContainer() : JTL!Predicate =
    if self->refImmediateComposite()->oclIsTypeOf(JTL!Predicate)
    	then self->refImmediateComposite()
    	else self->refImmediateComposite()->refImmediateComposite().getPredicateContainer()
    endif;

--- Recursively find ObjectTemplateExp
helper context JTL!ObjectTemplateExp def: getAllObjTplExp() : Sequence(JTL!ObjectTemplateExp) =
    if not self.inside.first().oclIsUndefined()
    	then Sequence{self, self.inside->select(a|a.isObjTplExp())->collect(a|a.value.first().getAllObjTplExp())}->flatten()
    	else Sequence{self}
    endif;

--- Check if a Predicate is nested
helper context JTL!Predicate def: isNested() : Boolean = self.conditionExpression.value.first().getAllObjTplExp()->size() > 1;

--- Check if two AssignExp are bijective:
--- check if domain1:metaclass1->domain2:metaclass2 and domain1:metaclass1->metaclass3 | metaclass2 != metaclass3
helper def: isBijectiveOld(relations:Sequence(JTL!Relation), a1:JTL!AssignExp, a2:JTL!AssignExp): Boolean =
    relations
    	->collect(r|r.domain->at(
    	    	a1.getPredicateContainer().pattern.domain.relation.domain->indexOf(a1.getPredicateContainer().pattern.domain)
    	    ))->collect(d|d.pattern.predicate)->flatten()
    	->select(p|p.conditionExpression.isObjTplExp())
    	->collect(p|p.conditionExpression.value.first().getAllObjTplExp())->flatten()
    	->select(ote|ote.referredClass = a1.getTargetMetaclass())
    	->collect(ote|ote->refImmediateComposite().getPredicateContainer().pattern.domain.relation.domain->at(
    	    	a2.getPredicateContainer().pattern.domain.relation.domain->indexOf(a2.getPredicateContainer().pattern.domain)
    	    ))
    	->collect(d|d.pattern.predicate)->flatten()
    	->select(p|p.conditionExpression.isObjTplExp())
    	->collect(p|p.conditionExpression.value.first().getAllObjTplExp())->flatten()
    	->select(ote|ote.referredClass <> a2.getTargetMetaclass())
--    	->collect(ote|ote->refImmediateComposite().getPredicateContainer().pattern.domain.relation.name)
--    	->debug('bijective')
    	.isEmpty();

--- Check if two AssignExp are bijective:
helper def: isBijective(relations:Sequence(JTL!Relation), a1:JTL!AssignExp, a2:JTL!AssignExp): Boolean =
    relations
    	->collect(r|r.domain->at(
    	    	a2.getPredicateContainer().pattern.domain.relation.domain->indexOf(a2.getPredicateContainer().pattern.domain)
    	    ))->collect(d|d.pattern.predicate)->flatten()
    	->select(p|p.conditionExpression.isObjTplExp())
    	->collect(p|p.conditionExpression.value.first().getAllObjTplExp())->flatten()    	
    	->select(ote|ote.referredClass = a2.getTargetMetaclass()->debug('target'))
    	->collect(ote|ote->refImmediateComposite().getPredicateContainer().pattern.domain.relation.domain->at(
    	    	a1.getPredicateContainer().pattern.domain.relation.domain->indexOf(a1.getPredicateContainer().pattern.domain)
    	    ))
    	->collect(d|d.pattern.predicate)->flatten()
    	->select(p|p.conditionExpression.isObjTplExp())
    	->collect(p|p.conditionExpression.value.first().getAllObjTplExp())->flatten()
--    	->select(ote|ote.referredClass <> a1.getTargetMetaclass()->debug('source'))    	
		->collect(ote|ote.referredClass)
--    	->collect(ote|ote->refImmediateComposite().getPredicateContainer().pattern.domain.relation.name)
--    	->debug('bijective')
    	.isEmpty();

--- Check if a Relation is bijective in forward direction
--- Check that there are no other activated relations whith the same target pattern as this relation but different source pattern
helper context JTL!Relation def: isBijectiveFW(activatedRelations : Sequence(JTL!Relation)) : Boolean =
    activatedRelations
    	->select(r|r.domain->at(2).pattern.equals(self.domain->at(2).pattern) and
    	    	 not r.domain->at(1).pattern.equals(self.domain->at(1).pattern))
--    	->debug('BijiectiveFW')
    	.isEmpty();

--- Check if a Relation is bijective in backward direction
--- Check that there are no other activated relations whith the same source pattern as this relation but different target pattern
helper context JTL!Relation def: isBijectiveBW(activatedRelations : Sequence(JTL!Relation)) : Boolean =
    activatedRelations
    	->select(r|r.domain->at(1).pattern.equals(self.domain->at(1).pattern) and
    	    	 not r.domain->at(2).pattern.equals(self.domain->at(2).pattern))
--    	->debug('BijiectiveBW')
    	.isEmpty();

helper context JTL!Pattern def: equals(p : JTL!Pattern) : Boolean =
    p.getObjTplExpClasses()->asSet()->symetricDifference(self.getObjTplExpClasses()->asSet()).isEmpty();

helper context JTL!Pattern def: getObjTplExpClasses() : Sequence(String) =
    Sequence{self.templateExpression.referredClass,
    	self.predicate->select(p|p.conditionExpression.isObjTplExp())
    	->collect(p|p.conditionExpression.value.first().getAllObjTplExp())->flatten()
    	->collect(o|o.referredClass)}->flatten();
    

---------------------------------------------------------------------------------------------------
--                                          CALLED RULES
---------------------------------------------------------------------------------------------------

-- Rules for incrementing counters
rule newNodeId() { do { thisModule.nodeId <- thisModule.nodeId +1; thisModule.nodeId; } }
rule newPropId() { do { thisModule.propId <- thisModule.propId +1; thisModule.propId; } }
rule newEdgeId() { do { thisModule.edgeId <- thisModule.edgeId +1; thisModule.edgeId; } }
rule newRuleId() { do { thisModule.ruleId <- thisModule.ruleId +1; thisModule.ruleId; } }
rule newConstraintId() { do { thisModule.constraintId <- thisModule.constraintId +1; thisModule.constraintId; } }

--- Create a new Literal
rule newLiteral(name : String) {
    to
    	t : ASP!Literal (
    	    name <- name,
    	    transformation <- thisModule.transformation
    	)
    do {
        thisModule.literals <- thisModule.literals->including(name, t);
        t;
    }
}

--- Create a new Node
rule newNode(mm : String, id : String, idx : String, mc : String) {
    using { key : String = thisModule.toKey(Sequence{mm, id, idx, mc}); }
    to
    	t : ASP!Node (
    	    name <- 'node:' + thisModule.newNodeId() + ':' + key,
    	    literals <- thisModule.getLiteral(mm.normalize()),
    	    literals <- thisModule.getLiteral(id),
    	    literals <- thisModule.getLiteral(idx),
    	    literals <- thisModule.getLiteral(mc.normalize()),
    	    transformation <- thisModule.transformation
    	)
    do {
        thisModule.nodes <- thisModule.nodes->including(key, t);
        t;
    }
}

--- Create a new Nodex
rule newNodex(mm : String, id : String, idx : String, mc : String) {
    using { key : String = thisModule.toKey(Sequence{mm, id, idx, mc}); }
    to
    	t : ASP!Node (
    	    name <- 'nodex:' + thisModule.newNodeId() + ':' + key,
    	    isNodex <- true,
    	    literals <- thisModule.getLiteral(mm.normalize()),
    	    literals <- thisModule.getLiteral(id),
    	    literals <- thisModule.getLiteral(idx),
    	    literals <- thisModule.getLiteral(mc.normalize()),
    	    transformation <- thisModule.transformation
    	)
    do {
        thisModule.nodexs <- thisModule.nodexs->including(key, t);
        t;
    }
}

--- Create a new Prop
rule newProp(mm : String, idp : String, idpx : String, id : String,
             idx : String, name : String, value : String) {
    using { key : String = 
        thisModule.toKey(Sequence{mm, idp, idpx, id, idx, name, value});
    }
    to
    	t : ASP!Prop (
    	    name <- 'prop:' + thisModule.newPropId() + ':' + key,
    	    literals <- thisModule.getLiteral(mm.normalize()),
    	    literals <- thisModule.getLiteral(idp),
    	    literals <- thisModule.getLiteral(idpx),
    	    literals <- thisModule.getLiteral(id),
    	    literals <- thisModule.getLiteral(idx),
    	    literals <- thisModule.getLiteral(name.normalize()),
    	    literals <- thisModule.getLiteral(value),
    	    transformation <- thisModule.transformation
    	)
    do {
        thisModule.props <- thisModule.props->including(key, t);
        t;
    }
}

--- Create a new Propx
rule newPropx(mm : String, idp : String, idpx : String, id : String,
             idx : String, name : String, value : String) {
    using { key : String = 
        thisModule.toKey(Sequence{mm, idp, idpx, id, idx, name, value});
    }
    to
    	t : ASP!Prop (
    	    name <- 'propx:' + thisModule.newPropId() + ':' + key,
    	    isPropx <- true,
    	    literals <- thisModule.getLiteral(mm.normalize()),
    	    literals <- thisModule.getLiteral(idp),
    	    literals <- thisModule.getLiteral(idpx),
    	    literals <- thisModule.getLiteral(id),
    	    literals <- thisModule.getLiteral(idx),
    	    literals <- thisModule.getLiteral(name.normalize()),
    	    literals <- thisModule.getLiteral(value),
    	    transformation <- thisModule.transformation
    	)
    do {
        thisModule.propxs <- thisModule.propxs->including(key, t);
        t;
    }
}

--- Create a new Edge
rule newEdge(mm : String, ide : String, idex : String, name : String,
             ids : String, idsx : String, idt : String, idtx : String) {
    using { key : String = thisModule.toKey(Sequence{mm, ide, idex, name, ids, idsx, idt, idtx});
    }
    to
    	t : ASP!Edge (
    	    name <- 'edge:' + thisModule.newEdgeId() + ':' + key,
    	    literals <- thisModule.getLiteral(mm.normalize()),
    	    literals <- thisModule.getLiteral(ide),
    	    literals <- thisModule.getLiteral(idex),
    	    literals <- thisModule.getLiteral(name.normalize()),
    	    literals <- thisModule.getLiteral(ids),
    	    literals <- thisModule.getLiteral(idsx),
    	    literals <- thisModule.getLiteral(idt),
    	    literals <- thisModule.getLiteral(idtx),
    	    transformation <- thisModule.transformation
    	)
    do {
        thisModule.edges <- thisModule.edges->including(key, t);
        t;
    }
}

--- Create a new Edgex
rule newEdgex(mm : String, ide : String, idex : String, name : String,
             ids : String, idsx : String, idt : String, idtx : String) {
    using { key : String = thisModule.toKey(Sequence{mm, ide, idex, name, ids, idsx, idt, idtx}); }
    to
    	t : ASP!Edge (
    	    name <- 'edgex:' + thisModule.newEdgeId() + ':' + key,
    	    isEdgex <- true,
    	    literals <- thisModule.getLiteral(mm.normalize()),
    	    literals <- thisModule.getLiteral(ide),
    	    literals <- thisModule.getLiteral(idex),
    	    literals <- thisModule.getLiteral(name.normalize()),
    	    literals <- thisModule.getLiteral(ids),
    	    literals <- thisModule.getLiteral(idsx),
    	    literals <- thisModule.getLiteral(idt),
    	    literals <- thisModule.getLiteral(idtx),
    	    transformation <- thisModule.transformation
    	)
    do {
        thisModule.edgexs <- thisModule.edgexs->including(key, t);
        t;
    }
}

--- Create a new function with a custom name (NamedFunction)
rule newNamedFunction(name : String, literals : Sequence(String)) {
    using { key : String = thisModule.toKey(literals->prepend(name)); }
    to
    	t : ASP!NamedFunction (
    	    name <- name,
    	    literals <- literals->collect(l|thisModule.newLiteral(l)),
    	    transformation <- thisModule.transformation
    	)
    do {
        thisModule.namedfunctions <- thisModule.namedfunctions->including(key, t);
        t;
    }
}

--- Create a new Metanode
rule newMetanode(mm : String, mc : String) {
    using { key : String = thisModule.toKey(Sequence{mm, mc}); }
    to
    	t : ASP!Metanode (
    	    name <- 'metanode:' + key,
    	    literals <- thisModule.getLiteral(mm.normalize()),
    	    literals <- thisModule.getLiteral(mc.normalize()),
    	    transformation <- thisModule.transformation
    	)
    do {
        thisModule.metanodes <- thisModule.metanodes->including(key, t);
        t;
    }
}

--- Create a new Metaprop
rule newMetaprop(mm : String, name : String, mc : String) {
    using { key : String = thisModule.toKey(Sequence{mm, name, mc}); }
    to
    	t : ASP!Metaprop (
    	    name <- 'metaprop:' + key,
    	    literals <- thisModule.getLiteral(mm.normalize()),
    	    literals <- thisModule.getLiteral(name.normalize()),
    	    literals <- thisModule.getLiteral(mc.normalize()),
    	    transformation <- thisModule.transformation
    	)
    do {
        thisModule.metaprops <- thisModule.metaprops->including(key, t);
        t;
    }
}

--- Create a new Metaedge
rule newMetaedge(mm : String, name : String, mcs : String, mct : String) {
    using { key : String = thisModule.toKey(Sequence{mm, name, mcs, mct}); }
    to
    	t : ASP!Metaedge (
    	    name <- 'metaedge:' + key,
    	    literals <- thisModule.getLiteral(mm.normalize()),
    	    literals <- thisModule.getLiteral(name.normalize()),
    	    literals <- thisModule.getLiteral(mcs.normalize()),
    	    literals <- thisModule.getLiteral(mct.normalize()),
    	    transformation <- thisModule.transformation
    	)
    do {
        thisModule.metaedges <- thisModule.metaedges->including(key, t);
        t;
    }
}

--- Create a new Terminal
rule newTerminal(e : ASP!Element) {
    to
    	t : ASP!Terminal (
    	    name <- e.name,
    	    element <- e,
    	    transformation <- thisModule.transformation
    	)
    do { t; }
}

--- Create a new Not Terminal
rule newNotTerminal(e : ASP!Element) {
    to
    	t : ASP!Not (
    	    name <- e.name,
    	    element <- e,
    	    transformation <- thisModule.transformation
    	)
    do { t; }
}

--- Create a new Relation node2node
rule newRelationNode(p1 : JTL!Pattern, p2 : JTL!Pattern) {
    using {
        relation : String = p1.domain.relation.name;
        mm1 : String = p1.getMetamodel();
    	mm2 : String = p2.getMetamodel();
        mc1 : String = p1.getMetaclass();
        mc2 : String = p2.getMetaclass();
    }
    to
    	t : ASP!Relation (
    	    id <- 'node2node:' + relation,
    	    name <- relation,
    	    type <- 'bidirectional',
    	    patterns <- left,
    	    patterns <- right
    	),
    	left : ASP!LeftPattern (
    	    name <- mm1 + ':' + mc1,
    	    type <- 'node',
    	    element <- thisModule.getMetanode(mm1, mc1)
    	),
    	right : ASP!RightPattern (
    	    name <- mm2 + ':' + mc2,
    	    type <- 'node',
    	    element <- thisModule.getMetanode(mm2, mc2)
    	)
    do {
        thisModule.transformation.relations <- t;
        t;
    }
}

--- Create a new Relation prop2prop
rule newRelationProp(p1 : JTL!Predicate, p2 : JTL!Predicate) {
    using {
        relation : String = p1.pattern.domain.relation.name;
        mm1 : String = p1.pattern.getMetamodel();
        mm2 : String = p2.pattern.getMetamodel();
    	name1 : String = p1.conditionExpression.left.name;
    	name2 : String = p2.conditionExpression.left.name;
    	mc1 : String = p1.pattern.getMetaclass();
    	mc2 : String = p2.pattern.getMetaclass();
    }
    to
    	t : ASP!Relation (
    	    id <- 'prop2prop:' + relation + '_' + mc1 + ':' + name1 + '2' + mc2 + ':' + name2,
    	    name <- relation + '_' + name1 + '2' + name2,
    	    type <- 'bidirectional',
    	    patterns <- left,
    	    patterns <- right
    	),
    	left : ASP!LeftPattern (
    	    name <- mm1 + ':' + name1 + '_' + mc1,
    	    type <- 'prop',
    	    element <- thisModule.getMetaprop(mm1, name1, mc1)
    	),
    	right : ASP!RightPattern (
    	    name <- mm2 + ':' + name2 + '_' + mc2,
    	    type <- 'prop',
    	    element <- thisModule.getMetaprop(mm2, name2, mc2)
    	)
    do {
        thisModule.transformation.relations <- t;
        t;
    }
}

--- Create a new Relation edge2edge
rule newRelationEdge(p1 : JTL!AssignExp, p2 : JTL!AssignExp) {
    using {
        relation : String = p1.getPredicateContainer().pattern.domain.relation.name;
        mm1 : String = p1.getMetamodel();
        mm2 : String = p2.getMetamodel();
    	name1 : String = p1.left.name;
    	name2 : String = p2.left.name;
    	mcs1 : String = p1.getSourceMetaclass();
    	mcs2 : String = p2.getSourceMetaclass();
    	mct1 : String = p1.getTargetMetaclass();
    	mct2 : String = p2.getTargetMetaclass();
    }
    to
    	t : ASP!Relation (
    	    id <- 'edge2edge:' + relation + '_' + mcs1 + ':' + name1 + '2' + mcs2 + ':' + name2,
    	    name <- relation + '_' + name1 + '2' + name2,
    	    type <- 'bidirectional',
    	    patterns <- left,
    	    patterns <- right
    	),
    	left : ASP!LeftPattern (
    	    name <- mm1 + ':' + name1,
    	    type <- 'edge',
    	    element <- thisModule.getMetaedge(mm1, name1, mcs1, mct1)
    	),
    	right : ASP!RightPattern (
    	    name <- mm2 + ':' + name2,
    	    type <- 'edge',
    	    element <- thisModule.getMetaedge(mm2, name2, mcs2, mct2)
    	)
    do {
        thisModule.transformation.relations <- t;
        t;
    }
}

--- Create a new generic constraint
rule newConstraint(comment : String, expr : Sequence(ASP!Expression), direction : ASP!Literal) {
    to
		c : ASP!Constraint (
    	    comment <- comment,
    	    name <- 'Constraint_' + thisModule.newConstraintId(),
    	    expressions <- expr,
    	    direction <- direction,
    	    transformation <- thisModule.transformation
    	)
}

--- Create a new generic rul
rule newRule(comment : String, namedFunction : ASP!NamedFunction, expr : Sequence(ASP!Expression), direction : ASP!Literal) {
    to
		c : ASP!Rule (
    	    comment <- comment,
    	    name <- namedFunction.name + '_' + thisModule.newRuleId(),
    	    head <- thisModule.newTerminal(namedFunction),
    	    expressions <- expr,
    	    direction <- direction,
    	    transformation <- thisModule.transformation
    	)
    
}

--- Create a new node2node constraint
rule newNode2NodeConstraint(p1 : JTL!Pattern, p2 : JTL!Pattern) {
    using {
        relation : String = p1.domain.relation.name;
        mm1 : String = p1.getMetamodel();
    	mm2 : String = p2.getMetamodel();
        mc1 : String = p1.getMetaclass();
        mc2 : String = p2.getMetaclass();
    	id : String = 'ID';
    	idx : String = 'IDx';
    }
    to
    	t : ASP!Constraint (
    	    comment <- '% ' + relation + ':' + mc1 + ' -> ' + mc2,
    	    name <- 'Constraint_' + thisModule.newConstraintId(),
    	    expressions <- thisModule.newTerminal(thisModule.getNode(mm1, id, idx, mc1)),		-- node(MM1, ID, IDx, MC1)
    	    expressions <- thisModule.newNotTerminal(thisModule.getNodex(mm2, id, idx, mc2)),	-- not nodex(MM2, ID, IDx, MC2)
    	    direction <- thisModule.getLiteral(mm2.normalize()),											-- mmt=MM2
    	    transformation <- thisModule.transformation
    	)
}

--- Create a new prop2prop constraint
rule newProp2PropConstraint(p1 : JTL!Predicate, p2 : JTL!Predicate) {
    using {
        relation : String = p1.pattern.domain.relation.name;
        mm1 : String = p1.pattern.getMetamodel();
        mm2 : String = p2.pattern.getMetamodel();
    	name1 : String = p1.conditionExpression.left.name;
    	name2 : String = p2.conditionExpression.left.name;
    	mc1 : String = p1.pattern.getMetaclass();
    	mc2 : String = p2.pattern.getMetaclass();
    	id : String = 'ID';
    	idx : String = 'IDx';
    	idp : String = 'IDp';
    	idpx : String = 'IDpx';
    	value : String = 'Value';
    }
    to
    	t : ASP!Constraint (
    	    comment <- '% ' + relation + ':' + mc1 + '.' + name1 + ' -> ' + mc2 + '.' + name2,
    	    name <- 'Constraint_' + thisModule.newConstraintId(),
    	    expressions <- thisModule.newTerminal(thisModule.getNode(mm1, id, idx, mc1)),							-- node(MM1, ID, IDx, MC1)
    	    expressions <- thisModule.newTerminal(thisModule.getProp(mm1, idp, idpx, id, idx, name1, value)),		-- prop(MM1, IDp, IDpx, ID, IDx, name1, Value)
    	    expressions <- thisModule.newTerminal(thisModule.getNodex(mm2, id, idx, mc2)),							-- nodex(MM2, ID, IDx, MC2)
    	    expressions <- thisModule.newNotTerminal(thisModule.getPropx(mm2, idp, idpx, id, idx, name2, value)),	-- not propx(MM2, IDp, IDpx, ID, IDx, name2, Value)
    	    direction <- thisModule.getLiteral(mm2.normalize()),																-- mmt=MM2
    	    transformation <- thisModule.transformation
    	)    
}

--- Create a new edge2edge constraint
rule newEdge2EdgeConstraint(p1 : JTL!AssignExp, p2 : JTL!AssignExp) {
    using {
        relation : String = p1.getPredicateContainer().pattern.domain.relation.name;
        mm1 : String = p1.value.first().type;
        mm2 : String = p2.value.first().type;
    	name1 : String = p1.left.name;
    	name2 : String = p2.left.name;
    	mcs1 : String = p1.getSourceMetaclass();
    	mcs2 : String = p2.getSourceMetaclass();
    	mct1 : String = p1.value.first().referredClass;
    	mct2 : String = p2.value.first().referredClass;
    	ids : String = 'IDs';
    	idsx : String = 'IDsx';
    	idt : String = 'IDt';
    	idtx : String = 'IDtx';
    	ide : String = 'IDe';
    	idex : String = 'IDex';
    }
    to
    	t : ASP!Constraint (
    	    comment <- '% ' + relation + ':' + mcs1 + '.' + name1 + ' -> ' + mcs2 + '.' + name2,
    	    name <- 'Constraint_' + thisModule.newConstraintId(),
    	    expressions <- thisModule.newTerminal(thisModule.getNode(mm1, ids, idsx, mcs1)),							-- node(MM1, IDs, IDsx, MCS1)
    	    expressions <- thisModule.newTerminal(thisModule.getNode(mm1, idt, idtx, mct1)),							-- node(MM1, IDt, IDts, MCT1)
    	    expressions <- thisModule.newTerminal(thisModule.getEdge(mm1, ide, idex, name1, ids, idsx, idt, idtx)),		-- edge(MM1, IDe, IDex, name1, IDs, IDsx, IDt, IDtx)
    	    expressions <- thisModule.newTerminal(thisModule.getNodex(mm2, ids, idsx, mcs2)),							-- nodex(MM2, IDs, IDsx, MCS2)
    	    expressions <- thisModule.newTerminal(thisModule.getNodex(mm2, idt, idtx, mct2)),							-- nodex(MM2, IDt, IDtx, MCT2)
    	    expressions <- thisModule.newNotTerminal(thisModule.getEdgex(mm2, ide, idex, name2, ids, idsx, idt, idtx)),	-- not edgex(MM2, IDe, IDex, name2, IDs, IDsx, IDt, IDtx)
    	    direction <- thisModule.getLiteral(mm2.normalize()),																	-- mmt=MM2
    	    transformation <- thisModule.transformation    	    
    	)
    
}

--- Generate a conditional rule based on condition expressed in the triggering relation
rule newConditionalRule(p1 : JTL!AssignExp, p2 : JTL!AssignExp, relation : String) {
    using {
        mm1 : String = p1.getMetamodel();
        mm2 : String = p2.getMetamodel();
    	name1 : String = p1.left.name;
    	mcs1 : String = p1.getSourceMetaclass();
    	mct1 : String = p1.getTargetMetaclass();
    	ids : String = 'IDs';
    	idsx : String = 'IDsx';
    	idt : String = 'ID';
    	idtx : String = 'IDx';
    	ide : String = 'IDe';
    	idex : String = 'IDex';
    	triggeringRelation : String = p1.getPredicateContainer().pattern.domain.relation.name;
    	triggeringFunction : ASP!NamedFunction = thisModule.getNamedFunction(triggeringRelation, Sequence{idt, idtx});
    	function : ASP!NamedFunction = thisModule.getNamedFunction(relation, Sequence{idt, idtx});
    }
    to
    	r : ASP!Rule (
    	    comment <- '\n% Conditional rule: ' + triggeringRelation,
    	    name <- 'Rule_' + thisModule.newRuleId(),
    	    head <- thisModule.newTerminal(triggeringFunction),
    	    expressions <- thisModule.newTerminal(thisModule.getEdge(mm1, ide, idex, name1, ids, idsx, idt, idtx)),
    	    expressions <- thisModule.newTerminal(thisModule.getNode(mm1, ids, idsx, mcs1)),
    	    expressions <- thisModule.newTerminal(thisModule.getNode(mm1, idt, idtx, mct1)),
    	    direction <- thisModule.getLiteral(mm2.normalize()),
    	    transformation <- thisModule.transformation
    	),
    	r1 : ASP!Rule (
    	    comment <- '\n% Conditional rule: ' + relation,
    	    name <- 'Rule_' + thisModule.newRuleId(),
    	    head <- thisModule.newTerminal(function),
			expressions <- thisModule.newTerminal(triggeringFunction),
    	    direction <- thisModule.getLiteral(mm2.normalize()),
    	    transformation <- thisModule.transformation
    	)
    do { r1; }
}

--- Generate the constraints based on condition expressed in the triggering relation
rule newConditionalConstraints(p1 : JTL!AssignExp, p2 : JTL!AssignExp, relation : String) {
    using {
        mm1 : String = p1.getMetamodel();
        mm2 : String = p2.getMetamodel();
    	name1 : String = p1.left.name;
    	mcs1 : String = p1.getSourceMetaclass();
    	mct1 : String = p1.getTargetMetaclass();
    	mct2 : String = p2.getTargetMetaclass();
    	ids : String = 'IDs';
    	idsx : String = 'IDsx';
    	idt : String = 'ID';
    	idtx : String = 'IDx';
    	ide : String = 'IDe';
    	idex : String = 'IDex';
    	function : ASP!NamedFunction = thisModule.getNamedFunction(relation, Sequence{idt, idtx});
    }
    to
    	c1 : ASP!Constraint (
    	    comment <- '% Conditional rule: ' + relation,
    	    name <- 'Constraint_' + thisModule.newConstraintId(),
    	    expressions <- thisModule.newTerminal(thisModule.getNode(mm1, idt, idtx, mct1)),
    	    expressions <- thisModule.newTerminal(function),
    	    expressions <- thisModule.newNotTerminal(thisModule.getNodex(mm2, idt, idtx, mct2)),
    	    direction <- thisModule.getLiteral(mm2.normalize()),
    	    transformation <- thisModule.transformation
    	),
    	c2 : ASP!Constraint (
    	    comment <- '% Conditional rule: '+ relation,
    	    name <- 'Constraint_' + thisModule.newConstraintId(),
    	    expressions <- thisModule.newTerminal(thisModule.getNode(mm1, idt, idtx, mct1)),
    	    expressions <- thisModule.newNotTerminal(function),
    	    expressions <- thisModule.newTerminal(thisModule.getNodex(mm2, idt, idtx, mct2)),
    	    direction <- thisModule.getLiteral(mm2.normalize()),
    	    transformation <- thisModule.transformation
    	)
}

----- Generate the constraints based on condition expressed in the triggering relation
--rule newConditionalConstraints(p1: JTL!AssignExp, p2: JTL!AssignExp) {
--    using {
--        mm1 : String = p1.getMetamodel();
--        mm2 : String = p2.getMetamodel();
--    	name1 : String = p1.left.name;
--    	mcs1 : String = p1.getSourceMetaclass();
--    	mct1 : String = p1.getTargetMetaclass();
--    	mct2 : String = p2.getTargetMetaclass();
--    	ids : String = 'IDs';
--    	idsx : String = 'IDsx';
--    	idt : String = 'ID';
--    	idtx : String = 'IDx';
--    	ide : String = 'IDe';
--    	idex : String = 'IDex';
--    	relation : String = p1.getPredicateContainer().pattern.domain.relation.name;
--    	function : ASP!NamedFunction = thisModule.getNamedFunction(relation, Sequence{idt, idtx});
--    }
--    to
--    	r : ASP!Rule (
--    	    comment <- '\n% Conditional rule: ' + relation,
--    	    name <- 'Rule_' + thisModule.newRuleId(),
--    	    head <- thisModule.newTerminal(function),
--    	    expressions <- thisModule.newTerminal(thisModule.getEdge(mm1, ide, idex, name1, ids, idsx, idt, idtx)),
--    	    expressions <- thisModule.newTerminal(thisModule.getNode(mm1, ids, idsx, mcs1)),
--    	    expressions <- thisModule.newTerminal(thisModule.getNode(mm1, idt, idtx, mct1)),
--    	    direction <- thisModule.getLiteral(mm2.normalize()),
--    	    transformation <- thisModule.transformation
--    	),
--    	c1 : ASP!Constraint (
--    	    comment <- '% Conditional rule: ' + relation,
--    	    name <- 'Constraint_' + thisModule.newConstraintId(),
--    	    expressions <- thisModule.newTerminal(thisModule.getNode(mm1, idt, idtx, mct1)),
--    	    expressions <- thisModule.newTerminal(function),
--    	    expressions <- thisModule.newNotTerminal(thisModule.getNodex(mm2, idt, idtx, mct2)),
--    	    direction <- thisModule.getLiteral(mm2.normalize()),
--    	    transformation <- thisModule.transformation
--    	),
--    	c2 : ASP!Constraint (
--    	    comment <- '% Conditional rule: '+ relation,
--    	    name <- 'Constraint_' + thisModule.newConstraintId(),
--    	    expressions <- thisModule.newTerminal(thisModule.getNode(mm1, idt, idtx, mct1)),
--    	    expressions <- thisModule.newNotTerminal(function),
--    	    expressions <- thisModule.newTerminal(thisModule.getNodex(mm2, idt, idtx, mct2)),
--    	    direction <- thisModule.getLiteral(mm2.normalize()),
--    	    transformation <- thisModule.transformation
--    	)
--}

--- Generate a new mapping_edge (forward) from nested AssignExp
rule newMappingEdgeFW(p1 : JTL!AssignExp, p2 : JTL!AssignExp) {
    using {
        relation : String = p1.getPredicateContainer().pattern.domain.relation.name;
    	domain1_otes : Sequence(JTL!AssignExp) = p1.value.first().getAllObjTplExp();
    	domain2_otes : Sequence(JTL!AssignExp) = p2.value.first().getAllObjTplExp();
    	matchingOte1 : JTL!ObjectTemplateExp = domain1_otes.first();
    	matchingOte2 : JTL!ObjectTemplateExp = domain2_otes.first();
    	-- TODO check for when condition beside the base case
    	matchingSourceOte1 : JTL!ObjectTemplateExp = domain1_otes.first();
    	matchingSourceOte2 : JTL!ObjectTemplateExp = domain2_otes.first();
        mm1 : String = p1.getMetamodel();
        mm2 : String = p2.getMetamodel();
        edgeId : String = thisModule.newEdgeId();
        me_ide : String = 'IDe' + edgeId;
    	me_idex : String = 'IDex' + edgeId;
    	id : String = 'ID';
    	idx : String = 'IDx';
    	ids : String = 'IDs';
    	idsx : String = 'IDsx';
    	idt : String = 'IDt';
    	idtx : String = 'IDtx';
    	ide : String = 'IDe';
    	idex : String = 'IDex';
    }
    to
    	me : ASP!Rule (
    	    comment <- '\n% mapping_edge fw from nested predicate: ' + relation,
    	    name <- 'mapping_edge ' + thisModule.newRuleId(),
    	    transformation <- thisModule.transformation
    	)
   	do {
   	    -- find the ObjTplExps with matching variable names
   	    for (ote1 in domain1_otes) {
   	        for (ote2 in domain2_otes) {
   	            if (ote1.name = ote2.name) {
   	                matchingOte1 <- ote1;
   	                matchingOte2 <- ote2;
   	            }
   	        }
   	    }
   	    
   	    -- Create the mapping_edge head and expressions
   	    me.head <- thisModule.newTerminal(thisModule.getNamedFunction(
   	        'mapping_edge', Sequence{mm2.normalize(), ide, idex, matchingOte2.getMetaedgeName().normalize(), ids, idsx, idt, idtx}));
   	    
   	    -- domain1
   	    me.expressions <- thisModule.newTerminal(
   	        thisModule.getNode(mm1,
   	            if domain1_otes.first() = matchingSourceOte1 then ids else id + thisModule.newNodeId() endif,
   	            if domain1_otes.first() = matchingSourceOte1 then idsx else idx + thisModule.nodeId endif,
   	            p1.getSourceMetaclass()));
   	    
   	    for (ote in domain1_otes) {
   	        me.expressions <- thisModule.newTerminal(
   	            thisModule.getEdge(mm1,
   	                if ote = matchingOte1 then ide else ide + thisModule.newEdgeId() endif,
   	                if ote = matchingOte1 then idex else idex + thisModule.edgeId endif,
   	                ote.getMetaedgeName(),
   	                if ote = matchingSourceOte1 then ids else me.expressions.last().element.literals.at(2).name endif,
       	            if ote = matchingSourceOte1 then idsx else me.expressions.last().element.literals.at(3).name endif,
   	                if ote = matchingOte1 then idt else id + thisModule.newNodeId() endif,
   	                if ote = matchingOte1 then idtx else idx + thisModule.nodeId endif));
   	        me.expressions <- thisModule.newTerminal(
   	            thisModule.getNode(mm1,
   	                if ote = matchingOte1 then idt else me.expressions.last().element.literals.at(7).name endif,
   	                if ote = matchingOte1 then idtx else me.expressions.last().element.literals.at(8).name endif,
   	                ote.referredClass));
   	    }
   	    
   	    -- domain2
   	    me.expressions <- thisModule.newTerminal(
   	        thisModule.getNodex(mm2,
   	            if domain2_otes.first() = matchingSourceOte2 then ids else id + thisModule.newNodeId() endif,
   	            if domain2_otes.first() = matchingSourceOte2 then idsx else idx + thisModule.nodeId endif,
   	            p2.getSourceMetaclass()));
   	    
   	    for (ote in domain2_otes) {
   	        if (ote <> matchingOte2) {
       	        me.expressions <- thisModule.newTerminal(
       	            thisModule.getEdgex(mm2,
       	                ide + thisModule.newEdgeId(),
       	                idex + thisModule.edgeId,
       	                ote.getMetaedgeName(),
       	                me.expressions.last().element.literals.at(2).name,
       	                me.expressions.last().element.literals.at(3).name,
       	                id + thisModule.newNodeId(),
       	                idx + thisModule.nodeId));
   	        }
   	        me.expressions <- thisModule.newTerminal(
   	            thisModule.getNodex(mm2,
   	                if ote = matchingOte2 then idt else me.expressions.last().element.literals.at(7).name endif,
   	                if ote = matchingOte2 then idtx else me.expressions.last().element.literals.at(8).name endif,
   	                ote.referredClass));
   	    }
    	me;
   	}
}

--- Generate a new mapping_edge (backward) from nested AssignExp
rule newMappingEdgeBW(p1 : JTL!AssignExp, p2 : JTL!AssignExp) {
    using {
        relation : String = p1.getPredicateContainer().pattern.domain.relation.name;
    	domain1_otes : Sequence(JTL!AssignExp) = p1.value.first().getAllObjTplExp();
    	domain2_otes : Sequence(JTL!AssignExp) = p2.value.first().getAllObjTplExp();
    	matchingOte1 : JTL!ObjectTemplateExp = domain1_otes.first();
    	matchingOte2 : JTL!ObjectTemplateExp = domain2_otes.first();
        mm1 : String = p1.getMetamodel();
        mm2 : String = p2.getMetamodel();
    	id : String = 'ID';
    	idx : String = 'IDx';
    	ids : String = 'IDs';
    	idsx : String = 'IDsx';
    	idt : String = 'IDt';
    	idtx : String = 'IDtx';
    	ide : String = 'IDe';
    	idex : String = 'IDex';
    }
    to
    	me : ASP!Rule (
    	    comment <- '\n% mapping_edge bw from nested predicate: ' + relation,
    	    name <- 'mapping_edge ' + thisModule.newRuleId(),
    	    transformation <- thisModule.transformation
    	)
   	do {
   	    -- find the ObjTplExps with matching variable names
   	    for (ote1 in domain1_otes) {
   	        for (ote2 in domain2_otes) {
   	            if (ote1.name = ote2.name) {
   	                matchingOte1 <- ote1;
   	                matchingOte2 <- ote2;
   	            }
   	        }
   	    }
   	    
   	    -- Create the mapping_edge head and expressions
   	    me.head <- thisModule.newTerminal(thisModule.getNamedFunction(
   	        'mapping_edge', Sequence{mm1.normalize(), ide, idex, matchingOte1.getMetaedgeName().normalize(), ids, idsx, idt, idtx}));
   	    
   	    -- domain2
   	    me.expressions <- thisModule.newTerminal(
   	        thisModule.getNode(mm2, id + thisModule.newNodeId(), idx + thisModule.nodeId, p2.getSourceMetaclass()));
   	    
   	    for (ote in domain2_otes) {
   	        me.expressions <- thisModule.newTerminal(
   	            thisModule.getEdge(mm2,
   	                if ote = matchingOte2 then ide else ide + thisModule.newEdgeId() endif,
   	                if ote = matchingOte2 then idex else idex + thisModule.edgeId endif,
   	                ote.getMetaedgeName(),
   	                me.expressions.last().element.literals.at(2).name,
   	                me.expressions.last().element.literals.at(3).name,
   	                if ote = matchingOte2 then idt else id + thisModule.newNodeId() endif,
   	                if ote = matchingOte2 then idtx else idx + thisModule.nodeId endif));
   	        me.expressions <- thisModule.newTerminal(
   	            thisModule.getNode(mm2,
   	                me.expressions.last().element.literals.at(7).name,
   	                me.expressions.last().element.literals.at(8).name,
   	                ote.referredClass));
   	    }
   	    
   	    -- domain1
   	    me.expressions <- thisModule.newTerminal(
   	        thisModule.getNodex(mm1, id + thisModule.newNodeId(), idx + thisModule.nodeId, p1.getSourceMetaclass()));
   	    
   	    for (ote in domain1_otes) {
   	        if (ote <> matchingOte1) {
       	        me.expressions <- thisModule.newTerminal(
       	            thisModule.getEdgex(mm1,
       	                ide + thisModule.newEdgeId(),
       	                idex + thisModule.edgeId,
       	                ote.getMetaedgeName(),
       	                me.expressions.last().element.literals.at(2).name,
       	                me.expressions.last().element.literals.at(3).name,
       	                if domain1_otes.indexOf(ote) < domain1_otes.size() and
       	                   domain1_otes.at(domain1_otes.indexOf(ote)+1) = matchingOte1
       	                  then ids else id + thisModule.newNodeId() endif,
       	                if domain1_otes.indexOf(ote) < domain1_otes.size() and
       	                   domain1_otes.at(domain1_otes.indexOf(ote)+1) = matchingOte1
       	                  then idsx else idx + thisModule.nodeId endif));
   	        }
   	        me.expressions <- thisModule.newTerminal(
   	            thisModule.getNodex(mm1,
   	                if ote = matchingOte1 then idt else me.expressions.last().element.literals.at(7).name endif,
   	                if ote = matchingOte1 then idtx else me.expressions.last().element.literals.at(8).name endif,
   	                ote.referredClass));
   	    }
    	me;
   	}
}

--- Generate a new mapping_edge constraint from a mapping_edge
rule newMappingEdgeConstraint(relation : String, me : ASP!Rule) {
    using {
        mm : String = me.head.element.literals->at(1).name;
        ide : String = me.head.element.literals->at(2).name;
        idex : String = me.head.element.literals->at(3).name;
        name : String = me.head.element.literals->at(4).name;
        ids : String = me.head.element.literals->at(5).name;
        idsx : String = me.head.element.literals->at(6).name;
        idt : String = me.head.element.literals->at(7).name;
        idtx : String = me.head.element.literals->at(8).name;
    }
	to
	    c : ASP!Constraint (
	        comment <- '% mapping_edge constraint: ' + relation,
	        name <- 'Constraint_ME_' + thisModule.newConstraintId(),
	        expressions <- thisModule.newNotTerminal(thisModule.getEdgex(mm, ide, idex, name, ids, idsx, idt, idtx)),
	        expressions <- me.expressions->collect(t|thisModule.newTerminal(t.element)),
    	    transformation <- thisModule.transformation
	    )
}

--- Generate constraing for nested predicates in the non-bijective case
rule nonBijectiveNestedConstraints(otes : Sequence(TupleType(ote1:JTL!ObjectTemplateExp,ote2:JTL!ObjectTemplateExp))) {
    using {
        mm1 : String = otes->at(1).ote1->refImmediateComposite().getMetamodel();
    	mm2 : String = otes->at(1).ote2->refImmediateComposite().getMetamodel();
        direction : String = thisModule.getLiteral(otes->at(1).ote1->refImmediateComposite().getMetamodel().normalize());
    	alternativesFunction : String = otes->collect(t|t.ote1.getMetaedgeName())->sum();
    	allFunction : String = 'all_' + alternativesFunction;
    	id : String = 'ID';
    	idx : String = 'IDx';
    	ids : String = 'IDs';
    	idsx : String = 'IDsx';
    	idt : String = 'IDt';
    	idtx : String = 'IDtx';
    	ide : String = 'IDe';
    	idex : String = 'IDex';
    }
    to
    	r : ASP!Rule (
    	    comment <- '% non-bijective all alternatives rule: ',
    	    name <- allFunction + thisModule.newRuleId(),
    	    head <- thisModule.newTerminal(thisModule.getNamedFunction(allFunction, Sequence{ide, idex})),
    	    expressions <- otes->collect(t|thisModule.newTerminal(
    	        thisModule.getEdgex(mm1, ide, idex, t.ote1.getMetaedgeName(), ids, idsx, idt, idtx))),
    	    direction <- direction,
    	    transformation <- thisModule.transformation
    	),
    	c1 : ASP!Constraint (
    	    comment <- '% non-bijective "at least one" constraint: ',
    	    name <- 'at least one' + thisModule.newConstraintId(),
    	    expressions <- thisModule.newTerminal(thisModule.getEdge(mm2, ide, idex, otes->at(1).ote2.getMetaedgeName(), ids, idsx, idt, idtx)),
    	    expressions <- thisModule.newTerminal(thisModule.getNode(mm2, idt, idtx, otes->at(1).ote2.referredClass)),
    	    expressions <- thisModule.newNotTerminal(thisModule.getNamedFunction(alternativesFunction, Sequence{ide, idex})),
    	    direction <- direction,
    	    transformation <- thisModule.transformation
    	    
    	),
    	c2 : ASP!Constraint (
    	    comment <- '% non-bijective "not all togheter" constraint: ',
    	    name <- 'not all togheter' + thisModule.newConstraintId(),
    	    expressions <- thisModule.newTerminal(thisModule.getEdge(mm2, ide, idex, otes->at(1).ote2.getMetaedgeName(), ids, idsx, idt, idtx)),
    	    expressions <- thisModule.newTerminal(thisModule.getNode(mm2, idt, idtx, otes->at(1).ote2.referredClass)),
    	    expressions <- thisModule.newTerminal(thisModule.getNamedFunction(allFunction, Sequence{ide, idex})),
    	    direction <- direction,
    	    transformation <- thisModule.transformation
    	)
    do {
        for (t in otes) {
            thisModule.newRule(
                '% alternatives rule: ' + alternativesFunction + ' ' + t.ote1.getMetaedgeName(),
                thisModule.getNamedFunction(alternativesFunction, Sequence{ide, idex}),
                Sequence{thisModule.newTerminal(thisModule.getEdgex(mm1, ide, idex, t.ote1.getMetaedgeName(), ids, idsx, idt, idtx))},
                direction);
        }
    }
}

---------------------------------------------------------------------------------------------------
--                                           LAZY RULES
---------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------
--                                         MATCHED RULES
---------------------------------------------------------------------------------------------------

--- Create the root transformation element
rule Transformation2Transformation {
    from
		s : JTL!Transformation
    using {
        -- Select top relations or relations triggered by a where clause
        activatedRelations : Sequence(JTL!Relation) = s.relation->select(r|r.isTopLevel=true or r.isTriggeredByWhere());
        
        -- A map to group the ObjectTemplateExp of non-bijiective nested predicates
		nonBijectiveMappingEdges: Map (String, Sequence(TupleType(ote1: JTL!ObjectTemplateExp, ote2: JTL!ObjectTemplateExp))) = Map {};
    }
	to
		t : ASP!Transformation ( name <- s.name	)
	do {
	    thisModule.transformation <- t;
	    
	    for (r in activatedRelations) {
	        
    	    -- node2node relations
        	-- Before creating a new relation, check if a relation between the same metanodes exists	    
    	    if (not thisModule.relationNodeExists(r.domain->at(1).pattern.getMetanode(), r.domain->at(2).pattern.getMetanode())) {
    	        thisModule.newRelationNode(r.domain->at(1).pattern, r.domain->at(2).pattern);
    	    }
    	    
    	    -- Check if this relation is activated by a where clause
    	    -- and if triggering relation contains defined predicates
    	    if (r.isTriggeredByWhere() and
    	        r.getTriggeringRelations()->collect(r|r.domain)->flatten()->collect(d|d.pattern)
    	        ->collect(a|a.predicate)->flatten()->collect(a|a.conditionExpression).notEmpty()) {
        		
    	        -- Iterate over relations triggering this one
    	        for (triggering in r.getTriggeringRelations()) {
	                -- Look in the triggering relation for ObjTplExp with matching variable names
	                for (ote1 in triggering.domain->at(1).pattern.predicate->select(p|p.conditionExpression.isObjTplExp())
						   ->collect(p|p.conditionExpression.value.first().getAllObjTplExp())->flatten()) {
        				for (ote2 in triggering.domain->at(2).pattern.predicate->select(p|p.conditionExpression.isObjTplExp())
        						->collect(p|p.conditionExpression.value.first().getAllObjTplExp())->flatten()) {
        				    if (ote1.name = ote2.name) {
        				        -- Create a new relation_edge
--        				        if (not thisModule.relationEdgeExists(ote1->refImmediateComposite().getMetaedge(), ote2->refImmediateComposite().getMetaedge())) {
--        				        	thisModule.newRelationEdge(ote1->refImmediateComposite(), ote2->refImmediateComposite());
--        				        }            				        
        				        -- Create a new conditional rule for this triggering relation
        				        thisModule.newConditionalRule(ote1->refImmediateComposite(), ote2->refImmediateComposite(), r.name);
        				        
        				        -- Check if this is the last triggering relation to be processed
        				        if (r.getTriggeringRelations().indexOf(triggering) = r.getTriggeringRelations().size()) {
            				        -- Create conditional constraints for the forward direction
            				        if (triggering.isBijectiveFW(activatedRelations)) {
            				            thisModule.newConditionalConstraints(ote1->refImmediateComposite(), ote2->refImmediateComposite(), r.name);
            				        }
            				        -- Create conditional constraints for the backward direction
            				        if (triggering.isBijectiveBW(activatedRelations)) {
            				            thisModule.newConditionalConstraints(ote2->refImmediateComposite(), ote1->refImmediateComposite(), r.name);            				            
            				        }
        				        }
        				    }
        				}
        			}
    	        }
    	    } else {
	            thisModule.newNode2NodeConstraint(r.domain->at(1).pattern, r.domain->at(2).pattern);
	            thisModule.newNode2NodeConstraint(r.domain->at(2).pattern, r.domain->at(1).pattern);
	        }
	        
	        -- prop2prop relations: matching variables names
	        for (p1 in r.domain->at(1).pattern.predicate->select(p|p.isVarExp())) {
	            for (p2 in r.domain->at(2).pattern.predicate->select(p|p.isVarExp())) {
	                if (p1.conditionExpression.value.first().name = p2.conditionExpression.value.first().name) {
	                    thisModule.newRelationProp(p1, p2);
	                    thisModule.newProp2PropConstraint(p1, p2);
	                    thisModule.newProp2PropConstraint(p2, p1);
	                }
	            }
	        }
	        
	        -- edge2edge relations: matching variables names
	        for (p1 in r.domain->at(1).pattern.predicate->select(p|p.conditionExpression.isObjTplExp())->collect(e|e.conditionExpression)) {
	            for (p2 in r.domain->at(2).pattern.predicate->select(p|p.conditionExpression.isObjTplExp())->collect(e|e.conditionExpression)) {	                
	                if (p1->refImmediateComposite().isNested() or p2->refImmediateComposite().isNested()) {	                    
	                    -- mapping_edge and mapping_edge constraints
	                    if (r.isBijectiveFW(activatedRelations)) {
	                        thisModule.newMappingEdgeConstraint(r.name, thisModule.newMappingEdgeFW(p1, p2));
	                    } else {
	                        thisModule.newMappingEdgeFW(p1, p2);
	                    }

	                    if (r.isBijectiveBW(activatedRelations)) {
	                        thisModule.newMappingEdgeConstraint(r.name, thisModule.newMappingEdgeBW(p1, p2));
	                    } else {
	                    	thisModule.newMappingEdgeBW(p1, p2);
	                    	
	                    	-- Select ObjectTemplateExp with matching variable names
                       	    for (ote1 in p1.value.first().getAllObjTplExp()) {
                       	        for (ote2 in p2.value.first().getAllObjTplExp()) {
                       	            if (ote1.name = ote2.name) {
                       	                -- Store them in the nonBijectiveMappingEdges to be used later in
                       	                -- the generation of combined constraints for the non-bijective case                       	                
                       	                nonBijectiveMappingEdges <- nonBijectiveMappingEdges->including(ote2.referredClass,
                       	                    if nonBijectiveMappingEdges->get(ote2.referredClass).oclIsUndefined()
                       	                      then Sequence{Tuple{ote1=ote1,ote2=ote2}}
                       	                      else nonBijectiveMappingEdges->get(ote2.referredClass)->append(Tuple{ote1=ote1,ote2=ote2})
                       	                    endif);
                       	            }
                       	        }
                       	    }
	                    }
	                } else if (p1.value.first().name = p2.value.first().name) {
	                    thisModule.newRelationEdge(p1, p2);
	                    
	                    if (r.isBijectiveFW(activatedRelations)) {
	                    	thisModule.newEdge2EdgeConstraint(p1, p2);
	                    }
	                    
						if (r.isBijectiveBW(activatedRelations)) {
	                    	thisModule.newEdge2EdgeConstraint(p2, p1);
	                    }
	                }
	            }
	        }
	        
	        -- edge2edge relations: variables related by a 'when' call
	        -- When the 'when' clause is set
	        if (not r.when.oclIsUndefined()) {
	            
	            -- Look for Predicates of type OperationCallExp matching any relation
	            for (calledRelation in activatedRelations) {
	                for (p in r.when.predicate->select(p|p.OpCallExpMatchesRelation(calledRelation))) {
	                    
	                    -- Look for Predicates in domain 1 matching one of the OperationCallExp parameters
	                    for (p1 in r.domain->at(1).pattern.predicate->select(p1|p1.predMatchesOpCallParams(p))) {
	                        
	                        -- Look for Predicates in domain 2 matching one of the OperationCallExp parameters
	                        for (p2 in r.domain->at(2).pattern.predicate->select(p2|p2.predMatchesOpCallParams(p))) {
	                            
	                            -- Check if predicates are nested
	                            if (not p1.isNested() and not p2.isNested() and
	                                not thisModule.relationEdgeExists(p1.conditionExpression.getMetaedge(), p2.conditionExpression.getMetaedge())) {
		                            thisModule.newRelationEdge(p1.conditionExpression, p2.conditionExpression);
		                            
		                            -- Check if bijective FW
		                            if (r.isBijectiveFW(activatedRelations)) {
            	                    	thisModule.newEdge2EdgeConstraint(p1.conditionExpression, p2.conditionExpression);
		                            }
		                            
		                            -- Check if bijective BW
		                            if (r.isBijectiveBW(activatedRelations)) {
            	                    	thisModule.newEdge2EdgeConstraint(p2.conditionExpression, p1.conditionExpression);
		                            }
	                            }	                            
	                        }
	                    }
	                }
	            }
	        }
	    }
	        
        -- Generate constraing for nested predicates in the non-bijective case
        for (otes in nonBijectiveMappingEdges->getValues()) {
        	thisModule.nonBijectiveNestedConstraints(otes);
        }
	}
}
