-- @atlcompiler atl2006

-- @name		MM2ASPmGenerator
-- @version		1.0
-- @authors		Ivano Malavolta
-- @date		2009/09/18
-- @description	${description}

-- This is an higher-order transformation that takes as input an Ecore metamodel MMx and produces
-- a model transformation producing the ASPm version of any model conforming to MMx.

query MM2ASPmGenerator = ECORE!EClass.allInstancesFrom('IN')->reject(e | e.abstract)->iterate(e; acc : String = 
	'-- @atlcompiler atl2006\n' +
	'-- Generated by: MM2ASPmGenerator\n' +
	'module ' + thisModule.getRoot().name + '2ASPm;\n\n' +
	'create OUT : ASPm from IN : ' + thisModule.getRoot().name + '; \n\n' +
	'helper def: model : ASPm!Model = OclUndefined;\n\n' +
	'helper def: rootElement : OclAny = ' + thisModule.getRoot().name + '!EObject.allInstancesFrom(\'IN\')->select(e | e.refImmediateComposite().oclIsUndefined()).first();\n\n' +
	'helper context String def : normalize() : String = \'x_\' + self;\n\n' +
	'helper context String def : processList(name : String) : String = self.regexReplaceAll(\'^[^,]+(,[^,]+)+$\',name+\'(["$0"])\').regexReplaceAll(\',([^,]+)\',\'","x_$1\');\n\n' +
	'helper context String def : getId() : String =\n' + 
	'if(self.contains(\'__idTrace:\')) then\n' +
	'\tself.split(\'_ASPid_\').at(1)\n' +
	'else\n' +
	'\tthisModule.count().toString()\n' +
	'endif;\n\n' +
	'helper context String def : getIdTrace() : String =\n' +
	'if(self.contains(\'__idTrace:\')) then\n' +
	'\tself.split(\'_ASPid_\').at(2)\n' +
	'else\n' +
	'\tself\n' +
	'endif;\n\n' +
	'helper def: counter : Integer = 0;\n\n' +
	'rule count() {\n' +
		'\t do {\n' +
		'\t\tthisModule.counter <- thisModule.counter + 1;\n' +
		'\t\tthisModule.counter;\n' +
		'\t}\n' +
	'}\n\n' +
	'entrypoint rule createModel() {\n' +
		'\t to\n' +
		'\t\tt : ASPm!Model (\n' +
		'\t\t\tID <- (\'m\' + thisModule.rootElement.__xmiID__).normalize(),\n' +
		'\t\t\tname <- \'' + thisModule.getRoot().name + '\'.normalize()\n' +
		'\t\t)\n' +	
		'\t do {\n' +
		'\t\tthisModule.model<- t;\n' +	
		'\t}\n' +
	'}\n\n' +
	'rule createProp(s : ' + thisModule.getRoot().name + '!Eobject, tuple : TupleType(attr : ' + thisModule.getRoot().name + '!EAttribute, value : String)) {\n'+
	'to\n'+
	'\tt : ASPm!Prop(\n'+
	-- assunzione: gli attributi hanno tutti cardinalitï¿½ <= 1
	'\t\tIDtrace <- (s.__xmiID__.getIdTrace() + s.eClass().eAllAttributes.indexOf(tuple.attr).toString()).normalize(),\n'+
	'\t\tID <- s.__xmiID__.getId() + s.eClass().eAllAttributes.indexOf(tuple.attr).toString(),\n'+
	'\t\tname <- tuple.attr.name.normalize(),\n'+
	'\t\tvalue <- tuple.value.normalize().processList(tuple.attr.name.normalize()),\n'+
	'\t\tmodel <- thisModule.model,\n'+
	'\t\towner <- s,\n'+
	'\t\townerTrace <- t.owner.IDtrace\n'+
	'\t)\n'+
	'\tdo {\n'+
	'\t\tt;\n'+
	'\t}\n'+
	'}\n\n' +
	'rule createEdge(s : ' + thisModule.getRoot().name + '!Eobject, tuple : TupleType(ref : ' + thisModule.getRoot().name + '!EReference, target : ' + thisModule.getRoot().name + '!Eobject)) {\n'+
	'to\n'+
	'\tt : ASPm!Edge(\n'+
	'\t\tIDtrace <- (s.__xmiID__.getIdTrace() + thisModule.count().toString()).normalize(),\n'+
	'\t\tID <- s.__xmiID__.getId() + thisModule.count().toString(),\n'+
	'\t\tname <- tuple.ref.name.normalize(),\n'+
	'\t\tmodel <- thisModule.model,\n'+
	'\t\tsource <- s,\n'+
	'\t\tsourceTrace <- t.source.IDtrace,\n'+
	'\t\ttarget <- tuple.target,\n'+
	'\t\ttargetTrace <- tuple.target.__xmiID__.getIdTrace().normalize()\n'+
	'\t)\n'+
	'\tdo {\n'+
	'\t\tt;\n'+
	'\t}\n'+
	'}\n\n' 
	| acc + e.toRuleString()).println();

-- adapt the following helper to reflect your file path
helper context String def : path : String =
	 '/ASPecore/transformations/generated/' + self;

helper context ECORE!EClass def : toRuleString() : String =
			'rule ' + self.rulename + ' {\n' +
			'\tfrom s : ' + thisModule.getRoot().name.toKString() + '!' + self.cname + '(s.oclIsTypeOf(' + thisModule.getRoot().name.toKString() + '!' + self.cname + '))\n' +	
			'\tto  t : ASPm!Node' + ' (\n' +
			'\t\tIDtrace <- s.__xmiID__.getIdTrace().normalize(),\n' +
			'\t\tID <- s.__xmiID__.getId(),\n' +
			'\t\tmodel <- thisModule.model,\n' +
			'\t\tname <- \'' + self.cname + '\'.normalize()\n' +
			'\t)\n' +
			'\tdo {\n'+
			'\t\ts.eClass().eAllReferences->select(e | s.eGet(e) <> e.defaultValue)->iterate(e; acc : Sequence(OclAny) = Sequence{} | acc.append((Sequence{s.eGet(e)}->flatten()->collect(e2 | Tuple{ref = e, target = e2})))).flatten()->collect(e | thisModule.createEdge(s, e));\n'+
			'\t\ts.eClass().eAllAttributes->select(e | s.eGet(e) <> e.defaultValue)->iterate(e; acc : Sequence(OclAny) = Sequence{} | acc.append((Sequence{s.eGet(e)}->flatten()->collect(e2 | Tuple{attr = e, value = e2.toString()})))).flatten()->collect(e | thisModule.createProp(s, e));\n'+
			'\t}\n'+
			'}\n\n';

helper context OclAny def: isRoot() : Boolean = self.refImmediateComposite().oclIsUndefined();

helper def: getRoot() : ECORE!EPackage = ECORE!EPackage.allInstancesFrom('IN')->any(e | e.isRoot());

helper context ECORE!ENamedElement def : qName : String =
	self.name;

helper context ECORE!EClassifier def : qName : String =
	if self.ePackage.oclIsUndefined() then
		self.name
	else
		self.ePackage.qName + '::' + self.name
	endif;

helper context ECORE!EPackage def : qName : String =
	if self.eSuperPackage.oclIsUndefined() then
		self.name
	else
		self.eSuperPackage.qName + '::' + self.name
	endif;

helper context ECORE!ENamedElement def : cname : String =
	if self.useQualifiedName then
		'"' + self.qName + '"'
	else
		if self.name.isKeyword then
			'"' + self.name + '"'
		else
			self.name
		endif
	endif;

helper context ECORE!ENamedElement def : rulename : String =
	if self.useQualifiedRuleName then
		'"' + self.qName + '"'
	else
		if self.name.isKeyword then
			'"' + self.name + '"'
		else
			self.name
		endif 
	endif;

helper context String def : toKString() : String =
	if self.isKeyword then
		'"' + self + '"'
	else
		self
	endif;

-- adapt the following inclusion condition for your specific model
helper context ECORE!"ecore::EClass" def : inclusionCondition : Boolean =
	not (
    	-- self.name = 'EAttribute' or
	    -- self.name = 'EClass' or
		-- self.name = 'EDataType' or
		-- self.name = 'EEnum' or
		-- self.name = 'EEnumLiteral' or
		self.name = 'EFactory' or
		self.name = 'EObject' or
		self.name = 'EOperation' or
		-- self.name = 'EPackage' or
		self.name = 'EParameter' or
		-- self.name = 'EReference' or
		self.name = 'Profile' or
		self.name = 'Stereotype'
	);

-- select whether or not to use fully qualified meta-class names (<package>::<class>)
helper context ECORE!"ecore::ENamedElement" def : useQualifiedName : Boolean =
	false; 

-- select whether or not to use fully qualified rule names (<package>::<class>)
helper context ECORE!"ecore::ENamedElement" def : useQualifiedRuleName : Boolean =
	false;

-- select whether or not to copy the __xmiid__ attribute
helper context ECORE!"ecore::EClass" def : copyXmiID : Boolean =
	false;

helper context String def : isKeyword : Boolean =
	Set{'module', 'create', 'from', 'rule', 'to', 'using', 'helper', 'context',
		'def', 'and', 'or', 'not', 'if', 'then', 'else', 'endif', 'query',
		'library', 'mapsTo', 'String', 'Boolean', 'Integer', 'Real', 'Bag',
		'Set', 'OrderedSet', 'Sequence', 'abstract', 'derived', 'refining',
		'foreach', 'distinct', 'in', 'do', 'uses', 'let', 'TupleType'}->includes(self);
