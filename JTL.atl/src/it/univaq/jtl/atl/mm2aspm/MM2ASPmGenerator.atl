-- @atlcompiler atl2006

-- @name		MM2ASPmGenerator
-- @version		1.0
-- @authors		Ivano Malavolta
-- @date		2009/09/18
-- @description	${description}

-- This is an higher-order transformation that takes as input an Ecore metamodel MMx and produces
-- a model transformation producing the ASPm version of any model conforming to MMx.

query MM2ASPmGenerator = ECORE!EClass.allInstancesFrom('IN')->reject(e | e.abstract)->iterate(e; acc : String = 
	'-- @atlcompiler atl2006\n' +
	'-- Generated by: MM2ASPmGenerator\n' +
	'module ' + thisModule.getRoot().name + '2ASPm;\n\n' +
	'create OUT : ASPm from IN : ' + thisModule.getRoot().name + '; \n\n' +
	'helper def: nodeCounter : Integer =' +
    	'\n\tif(' + thisModule.getRoot().name + '!EObject.allInstancesFrom(\'IN\')->select(e|e.__xmiID__.startsWith(\'ASPid_\')).notEmpty()) then' +
    	'\n\t\t' + thisModule.getRoot().name + '!EObject.allInstancesFrom(\'IN\')->collect(e|e.__xmiID__.split(\'-\'))->flatten()' +
    	'\n\t\t->select(e|e.startsWith(\'ASPid_\'))->collect(e|e.split(\'_\')->at(2).toInteger())' +
    	'\n\t\t->sortedBy(e|e)->last()' +
    	'\n\telse 0 endif;\n' +
	'helper def: featCounter : Integer = 0;\n' +
	'helper def: model : ASPm!Model = OclUndefined;\n' +
	'helper def: rootElement : OclAny = ' + thisModule.getRoot().name + '!EObject.allInstancesFrom(\'IN\')->select(e | e.refImmediateComposite().oclIsUndefined()).first();\n' +
	'helper def: ids : Set(Integer) =' + 
        '\n\t' + thisModule.getRoot().name + '!EObject.allInstancesFrom(\'IN\')->select(e|e.__xmiID__.startsWith(\'ASPid_\'))' +
    	'\n\t->collect(e|e.__xmiID__.split(\'-\'))->flatten()' +
    	'\n\t->collect(e|e.split(\'_\')->at(2))->asSet();\n' +
	'helper context String def : normalize() : String = \'x_\' + self;\n' +
	'helper context String def : processList(name : String) : String = self.regexReplaceAll(\'^[^,]+(,[^,]+)+$\',\'x_list(["$0"])\').regexReplaceAll(\',([^,]+)\',\'","x_$1\');\n' +
	'helper context String def : cleanIDref() : String = self.regexReplaceAll(\'@\',\'/@\').regexReplaceAll(\'^/@\',\'//@\');\n' +
	'helper context String def : getId() : String = self.split(\'_\').at(2);\n' +
	'helper context String def : getIdTrace() : String = self.split(\'_\').at(3).regexReplaceAll(\'^([^/])\',\'/$0\');\n' +
	'helper def : getNodeId(s:' + thisModule.getRoot().name + '!EObject) : String = ' +
		'\n\tif(s.__xmiID__.contains(\'ASPid_\')) then' +
		'\n\t\ts.__xmiID__.split(\'-\').at(1).getId()' +
		'\n\telse thisModule.setID(s).toString() endif;\n' +
	'helper def : getNodeIdTrace(s:' + thisModule.getRoot().name + '!EObject) : String = ' +
		'\n\tif(s.__xmiID__.contains(\'ASPid_\')) then' +
		'\n\t\tif(s.__xmiID__.split(\'-\').at(1).split(\'_\').size()=3) then' +
		'\n\t\t\ts.__xmiID__.split(\'-\').at(1).getIdTrace() else \'/\' endif' +
		'\n\telse s.__xmiID__ endif;\n' +
	'helper context String def : getSerializedString(name:String) : String =' +
        '\n\tif (self.indexOf(name + \'_\') <> -1) then' +
        '\n\t\tself.split(\'-\')->select(s | s.contains(name + \'_\')).first()' +
        '\n\telse \'\' endif;\n' +
	'helper def : getFeatureId(s:' + thisModule.getRoot().name + '!EObject, name:String) : String =' +
    	'\n\tif(s.__xmiID__.getSerializedString(name) <> \'\') then' +
    	'\n\t\ts.__xmiID__.getSerializedString(name).getId()' +
    	'\n\telse thisModule.featCount(s) endif;\n' +
	'helper def : getFeatureIdTrace(s:' + thisModule.getRoot().name + '!EObject, name:String) : String =' +
    	'\n\tif(s.__xmiID__.getSerializedString(name) <> \'\') then' +
    	'\n\t\ts.__xmiID__.getSerializedString(name).getIdTrace()' +
    	'\n\telse thisModule.getNodeIdTrace(s) + thisModule.featCount(s) endif;\n' +
	'rule stripFromXMIID(s:HSM!EObject, name:String) {' +
		'\n\tdo {' +
	    '\n\ts.__xmiID__ <- s.__xmiID__.split(\'-\')' +
	    	'\n\t\t->select(str | str <> s.__xmiID__.split(\'-\')' +
	    	    '\n\t\t\t->select(s | s.contains(name + \'_\')).first())' +
	    	'\n\t\t->collect(s|\'-\' + s).sum().regexReplaceAll(\'^-\',\'\');\n\t}\n}\n' +
	'rule nodeCount() {\n' +
	'\tdo {\n' +
		'\t\tthisModule.nodeCounter <- thisModule.nodeCounter + 1;\n' +
		'\t\tif (thisModule.nodeCounter.toString().contains(\'0\')) then\n' +
			'\t\t\tthisModule.nodeCount()\n' +
		'\t\telse thisModule.nodeCounter endif;\n\t}\n}\n' +
	'rule featCount(s:' + thisModule.getRoot().name + '!EObject) {\n' +
	 '\tdo {\n' +
		'\t\tthisModule.featCounter <- thisModule.featCounter + 1;\n' +
		'\t\tif (thisModule.ids.includes(thisModule.getNodeId(s) + \'0\' + thisModule.featCounter)) then\n' +
			'\t\t\tthisModule.featCount(s)\n' +
		'\t\telse thisModule.getNodeId(s) + \'0\' + thisModule.featCounter endif;\n\t}\n}\n' +
	'rule setID(s : ' + thisModule.getRoot().name + '!EObject) {\n' +
	'\tdo {\n' +
		'\t\ts.__xmiID__ <- \'ASPid_\' + thisModule.nodeCount() + \'_\' + s.__xmiID__;\n' +
		'\t\tthisModule.nodeCounter;\n\t}\n}\n' +
	'entrypoint rule createModel() {\n' +
		'\t to\n' +
		'\t\tt : ASPm!Model (\n' +
		'\t\t\tID <- (\'m\' + thisModule.getNodeId(thisModule.rootElement)).normalize(),\n' +
		'\t\t\tname <- \'' + thisModule.getRoot().name + '\'.normalize()\n' +
		'\t\t)\n' +	
		'\t do {\n' +
		'\t\tthisModule.model<- t;\n' +	
		'\t}\n' +
	'}\n\n' +
	'rule createProp(s : ' + thisModule.getRoot().name + '!EObject, tuple : TupleType(attr : ' + thisModule.getRoot().name + '!EAttribute, value : String)) {\n'+
	'to\n'+
	'\tt : ASPm!Prop(\n'+
	-- assunzione: gli attributi hanno tutti cardinalitï¿½ <= 1
	'\t\tIDtrace <- thisModule.getFeatureIdTrace(s, tuple.attr.name).normalize(),\n'+
	'\t\tID <- thisModule.getFeatureId(s, tuple.attr.name),\n'+
	'\t\tname <- tuple.attr.name.normalize(),\n'+
	'\t\tvalue <- tuple.value.normalize().processList(tuple.attr.name.normalize()),\n'+
	'\t\tmodel <- thisModule.model,\n'+
	'\t\towner <- s,\n'+
	'\t\townerTrace <- t.owner.IDtrace\n'+
	'\t)\n'+
	'\tdo {\n'+
	'\t\tthisModule.stripFromXMIID(s, tuple.attr.name);\n' +
	'\t\tt;\n'+
	'\t}\n'+
	'}\n\n' +
	'rule createEdge(s : ' + thisModule.getRoot().name + '!EObject, tuple : TupleType(ref : ' + thisModule.getRoot().name + '!EReference, target : ' + thisModule.getRoot().name + '!EObject)) {\n'+
	'using { featureName:String = tuple.ref.name + \'t\' + thisModule.getNodeId(tuple.target); }\n' +
	'to\n'+
	'\tt : ASPm!Edge(\n'+
	'\t\tIDtrace <- thisModule.getFeatureIdTrace(s, featureName).normalize(),\n'+
	'\t\tID <- thisModule.getFeatureId(s, featureName),\n'+
	'\t\tname <- tuple.ref.name.normalize(),\n'+
	'\t\tmodel <- thisModule.model,\n'+
	'\t\tsource <- s,\n'+
	'\t\tsourceTrace <- t.source.IDtrace,\n'+
	'\t\ttarget <- tuple.target,\n'+
	'\t\ttargetTrace <- thisModule.getNodeIdTrace(tuple.target).normalize()\n'+
	'\t)\n'+
	'\tdo {\n'+
	'\t\tthisModule.stripFromXMIID(s, featureName);\n' +
	'\t\tt;\n'+
	'\t}\n'+
	'}\n\n' 
	| acc + e.toRuleString())
	.println();
--	.writeTo(('MM2' + thisModule.getRoot().name + '.atl').path);

-- adapt the following helper to reflect your file path
helper context String def : path : String =
	 '/TEST.generated.MM2ASPm/transformation/' + self;

helper context ECORE!EClass def : toRuleString() : String =
			'rule ' + self.rulename + ' {\n' +
			'\tfrom s : ' + thisModule.getRoot().name.toKString() + '!' + self.cname + '(s.oclIsTypeOf(' + thisModule.getRoot().name.toKString() + '!' + self.cname + '))\n' +	
			'\tto  t : ASPm!Node' + ' (\n' +
			'\t\tIDtrace <- thisModule.getNodeIdTrace(s).normalize(),\n' +
			'\t\tID <- thisModule.getNodeId(s),\n' +
			'\t\tmodel <- thisModule.model,\n' +
			'\t\tname <- \'' + self.cname + '\'.normalize()\n' +
			'\t)\n' +
			'\tdo {\n'+
			'\t\ts.eClass().eAllReferences->select(e | s.eGet(e) <> e.defaultValue)->iterate(e; acc : Sequence(OclAny) = Sequence{} | acc.append((Sequence{s.eGet(e)}->flatten()->collect(e2 | Tuple{ref = e, target = e2})))).flatten()->collect(e | thisModule.createEdge(s, e));\n'+
			'\t\ts.eClass().eAllAttributes->select(e | s.eGet(e) <> e.defaultValue)->iterate(e; acc : Sequence(OclAny) = Sequence{} | acc.append((Sequence{s.eGet(e)}->flatten()->collect(e2 | Tuple{attr = e, value = e2.toString()})))).flatten()->collect(e | thisModule.createProp(s, e));\n'+
			'\t}\n'+
			'}\n\n';

helper context OclAny def: isRoot() : Boolean = self.refImmediateComposite().oclIsUndefined();

helper def: getRoot() : ECORE!EPackage = ECORE!EPackage.allInstancesFrom('IN')->any(e | e.isRoot());

helper context ECORE!ENamedElement def : qName : String =
	self.name;

helper context ECORE!EClassifier def : qName : String =
	if self.ePackage.oclIsUndefined() then
		self.name
	else
		self.ePackage.qName + '::' + self.name
	endif;

helper context ECORE!EPackage def : qName : String =
	if self.eSuperPackage.oclIsUndefined() then
		self.name
	else
		self.eSuperPackage.qName + '::' + self.name
	endif;

helper context ECORE!ENamedElement def : cname : String =
	if self.useQualifiedName then
		'"' + self.qName + '"'
	else
		if self.name.isKeyword then
			'"' + self.name + '"'
		else
			self.name
		endif
	endif;

helper context ECORE!ENamedElement def : rulename : String =
	if self.useQualifiedRuleName then
		'"' + self.qName + '"'
	else
		if self.name.isKeyword then
			'"' + self.name + '"'
		else
			self.name
		endif 
	endif;

helper context String def : toKString() : String =
	if self.isKeyword then
		'"' + self + '"'
	else
		self
	endif;

-- adapt the following inclusion condition for your specific model
helper context ECORE!"ecore::EClass" def : inclusionCondition : Boolean =
	not (
    	-- self.name = 'EAttribute' or
	    -- self.name = 'EClass' or
		-- self.name = 'EDataType' or
		-- self.name = 'EEnum' or
		-- self.name = 'EEnumLiteral' or
		self.name = 'EFactory' or
		self.name = 'EObject' or
		self.name = 'EOperation' or
		-- self.name = 'EPackage' or
		self.name = 'EParameter' or
		-- self.name = 'EReference' or
		self.name = 'Profile' or
		self.name = 'Stereotype'
	);

-- select whether or not to use fully qualified meta-class names (<package>::<class>)
helper context ECORE!"ecore::ENamedElement" def : useQualifiedName : Boolean =
	false; 

-- select whether or not to use fully qualified rule names (<package>::<class>)
helper context ECORE!"ecore::ENamedElement" def : useQualifiedRuleName : Boolean =
	false;

-- select whether or not to copy the __xmiid__ attribute
helper context ECORE!"ecore::EClass" def : copyXmiID : Boolean =
	false;

helper context String def : isKeyword : Boolean =
	Set{'module', 'create', 'from', 'rule', 'to', 'using', 'helper', 'context',
		'def', 'and', 'or', 'not', 'if', 'then', 'else', 'endif', 'query',
		'library', 'mapsTo', 'String', 'Boolean', 'Integer', 'Real', 'Bag',
		'Set', 'OrderedSet', 'Sequence', 'abstract', 'derived', 'refining',
		'foreach', 'distinct', 'in', 'do', 'uses', 'let', 'TupleType'}->includes(self);
